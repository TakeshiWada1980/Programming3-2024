<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <meta name="robots" content="noindex,nofollow,noarchive" />
    <meta name="referrer" content="no-referrer" />

    <script>
      MathJax = {
        chtml: {
          displayAlign: "left",
          displayIndent: "1em",
        },
      };
    </script>

     <script
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
type="text/javascript"></script> 

    <link rel="icon" href="favicon.ico" sizes="any" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css"
      integrity="sha512-SzlrxWUlpfuzQ+pcUCosxcglQRNAq/DZjVsC0lE40xsADsfeQoEypE+enwcOiGjk/bSuGGKHEyjSoQ1zVisanQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=M+PLUS+Rounded+1c"
    />
    <link rel="stylesheet" href="style.css" />

    <title>第03回 3I-プログラミング3</title>
  </head>

  <body>
    <div class="openbtn"><span></span><span></span><span></span></div>
    <nav id="g-nav">
      <div id="g-nav-list">
        <!-- ---------------------------------------- -->
         <ul>
<li><a href="#今回の授業概要と連絡" id="toc-今回の授業概要と連絡"><span
class="toc-section-number">1</span> 今回の授業概要と連絡</a>
<ul>
<li><a href="#小テスト❷" id="toc-小テスト❷"><span
class="toc-section-number">1.1</span> 小テスト❷</a></li>
<li><a href="#ここまでの流れ" id="toc-ここまでの流れ"><span
class="toc-section-number">1.2</span> ここまでの流れ</a></li>
</ul></li>
<li><a href="#vscodeの関連のtips" id="toc-vscodeの関連のtips"><span
class="toc-section-number">2</span> VSCodeの関連のTips</a>
<ul>
<li><a href="#vscodeの再読み込み" id="toc-vscodeの再読み込み"><span
class="toc-section-number">2.1</span> VSCodeの再読み込み</a></li>
<li><a href="#ファイルパス補完の拡張機能"
id="toc-ファイルパス補完の拡張機能"><span
class="toc-section-number">2.2</span>
ファイルパス補完の拡張機能</a></li>
<li><a href="#react開発の支援機能" id="toc-react開発の支援機能"><span
class="toc-section-number">2.3</span> React開発の支援機能</a></li>
<li><a href="#コードチェックツールの拡張機能"
id="toc-コードチェックツールの拡張機能"><span
class="toc-section-number">2.4</span>
コードチェックツールの拡張機能</a></li>
<li><a href="#tailwind用のインテリセンス"
id="toc-tailwind用のインテリセンス"><span
class="toc-section-number">2.5</span>
Tailwind用のインテリセンス</a></li>
</ul></li>
<li><a href="#前回の復習" id="toc-前回の復習"><span
class="toc-section-number">3</span> 前回の復習:</a>
<ul>
<li><a href="#オブジェクトのプロパティを変更ための2つのアプローチ"
id="toc-オブジェクトのプロパティを変更ための2つのアプローチ"><span
class="toc-section-number">3.1</span>
オブジェクトのプロパティを変更ための2つのアプローチ</a></li>
<li><a href="#react開発ではイミュータブルなオブジェクト更新を使用"
id="toc-react開発ではイミュータブルなオブジェクト更新を使用"><span
class="toc-section-number">3.2</span>
React開発では「イミュータブルなオブジェクト更新」を使用</a></li>
</ul></li>
<li><a href="#配列" id="toc-配列"><span
class="toc-section-number">4</span> 配列</a>
<ul>
<li><a href="#導入" id="toc-導入"><span
class="toc-section-number">4.1</span> 導入</a></li>
<li><a href="#型と宣言" id="toc-型と宣言"><span
class="toc-section-number">4.2</span> 型と宣言</a></li>
<li><a href="#参考-要素の追加と削除-ミュータブルな配列操作"
id="toc-参考-要素の追加と削除-ミュータブルな配列操作"><span
class="toc-section-number">4.3</span> 参考: 要素の追加と削除
(ミュータブルな配列操作)</a></li>
<li><a href="#要素の追加-イミュータブルな変更"
id="toc-要素の追加-イミュータブルな変更"><span
class="toc-section-number">4.4</span> 要素の追加
(イミュータブルな変更)</a></li>
<li><a href="#map-による要素の更新" id="toc-map-による要素の更新"><span
class="toc-section-number">4.5</span> map による要素の更新</a></li>
<li><a href="#配列のインデックス番号の参照"
id="toc-配列のインデックス番号の参照"><span
class="toc-section-number">4.6</span>
配列のインデックス番号の参照</a></li>
</ul></li>
<li><a href="#オブジェクト配列のmap操作"
id="toc-オブジェクト配列のmap操作"><span
class="toc-section-number">5</span> オブジェクト配列のmap操作</a>
<ul>
<li><a href="#準備-型定義の変更" id="toc-準備-型定義の変更"><span
class="toc-section-number">5.1</span> 準備 (型定義の変更)</a></li>
<li><a href="#オブジェクト型の配列の初期化"
id="toc-オブジェクト型の配列の初期化"><span
class="toc-section-number">5.2</span>
オブジェクト型の配列の初期化</a></li>
<li><a href="#オブジェクト型の配列に対するmapの適用"
id="toc-オブジェクト型の配列に対するmapの適用"><span
class="toc-section-number">5.3</span>
オブジェクト型の配列に対するmapの適用</a></li>
<li><a href="#任意の配列要素のプロパティの変更"
id="toc-任意の配列要素のプロパティの変更"><span
class="toc-section-number">5.4</span>
任意の配列要素のプロパティの変更</a></li>
</ul></li>
<li><a href="#オブジェクト配列のfilter操作"
id="toc-オブジェクト配列のfilter操作"><span
class="toc-section-number">6</span> オブジェクト配列のfilter操作</a>
<ul>
<li><a href="#filterメソッドの基本的な使用法"
id="toc-filterメソッドの基本的な使用法"><span
class="toc-section-number">6.1</span>
filterメソッドの基本的な使用法</a></li>
<li><a href="#オブジェクト型の配列に対するfilterの適用"
id="toc-オブジェクト型の配列に対するfilterの適用"><span
class="toc-section-number">6.2</span>
オブジェクト型の配列に対するfilterの適用</a></li>
</ul></li>
<li><a href="#オブジェクト配列のsort操作"
id="toc-オブジェクト配列のsort操作"><span
class="toc-section-number">7</span> オブジェクト配列のsort操作</a>
<ul>
<li><a href="#ソートキーを指定したオブジェクト配列の並び替え"
id="toc-ソートキーを指定したオブジェクト配列の並び替え"><span
class="toc-section-number">7.1</span>
ソートキーを指定したオブジェクト配列の並び替え</a></li>
<li><a href="#複数のソートキーを使ったオブジェクト配列の並び替え"
id="toc-複数のソートキーを使ったオブジェクト配列の並び替え"><span
class="toc-section-number">7.2</span>
複数のソートキーを使ったオブジェクト配列の並び替え</a></li>
</ul></li>
<li><a href="#メソッドチェーン-mapfiltersortの組み合わせ"
id="toc-メソッドチェーン-mapfiltersortの組み合わせ"><span
class="toc-section-number">8</span> メソッドチェーン
(map・filter・sortの組み合わせ)</a>
<ul>
<li><a href="#関数化" id="toc-関数化"><span
class="toc-section-number">8.1</span> 関数化</a></li>
</ul></li>
<li><a href="#宿題" id="toc-宿題"><span
class="toc-section-number">9</span> 宿題</a></li>
</ul> 
        <!-- ---------------------------------------- -->
      </div>
    </nav>

    <header class="markdown-body">
      <p>2024-3I プログラミング3 第03回 講義資料</p>
      <p>2024年10月17日（木）1・2時限</p>
    </header>

    <main class="markdown-body">
      <!-- ---------------------------------------- -->
      <h1 data-number="1" id="今回の授業概要と連絡"><span
      class="header-section-number">1</span> 今回の授業概要と連絡</h1>
      <p>本科目は学修単位科目です。<strong>1回の授業あたり、皆さんが「4時間相当の授業時間外学習」をすることを前提</strong>
      としたボリューム、展開速度となっています。いろいろと忙しいとは思いますが、時間を確保して取り組んでください。</p>
      <h2 data-number="1.1" id="小テスト❷"><span
      class="header-section-number">1.1</span> 小テスト❷</h2>
      <p>「小テスト❷」を実施します。筆記用具を準備しておいてください。</p>
      <h2 data-number="1.2" id="ここまでの流れ"><span
      class="header-section-number">1.2</span> ここまでの流れ</h2>
      <p>後期中間試験ぐらいまでの授業の流れ (予定)</p>
      <ol type="1">
      <li>モダンTypeScript基礎学習のための環境構築
      <strong><em>済</em></strong></li>
      <li>TypeScript基礎学習 <strong>← 前回と今回の授業のメイン</strong>
      <ul>
      <li>React / Next.js
      開発に関連する文法や機能だけを集中的に学びます。</li>
      </ul></li>
      <li>Reactを使ったTodoアプリのための環境構築 <strong>← 次回の授業
      (前半)</strong></li>
      <li>Todoアプリ開発（Reactによるフロントエンド開発）のチュートリアル
      <strong>← 次回の授業 (後半)</strong></li>
      <li>Todoアプリのカスタマイズや作り込み →
      <strong><em>後期前半の大課題</em></strong></li>
      </ol>
      <p>まずは、次のような <strong>Todoアプリの開発</strong>
      (Reactを採用したフロントエンド開発) を目標とします。</p>
      <ul>
      <li><a
      href="https://takeshiwada1980.github.io/react-todo-app-demo/">Todoアプリのサンプル</a>
      (ギリギリ合格水準のレベル、点数で言えば60点😨)</li>
      <li><a
      href="https://takeshiwada1980.github.io/react-todo-app-demo/2">Todoアプリのサンプル</a>
      (ここまでつくれたら素晴らしい！90点超🎉)</li>
      </ul>
      <h1 data-number="2" id="vscodeの関連のtips"><span
      class="header-section-number">2</span> VSCodeの関連のTips</h1>
      <h2 data-number="2.1" id="vscodeの再読み込み"><span
      class="header-section-number">2.1</span> VSCodeの再読み込み</h2>
      <p><code>[Ctrl]+[Shift]+[P]</code> で
      <strong>コマンドパレット</strong>
      を起動するか、VSCode上部の検索欄をクリックして
      <code>&gt;Developer: Reload Window</code>
      と入力すると「プロジェクトファイルの再読み込み」が行われます。</p>
      <p>2回目以降は、履歴から <code>&gt;Developer: Reload Window</code>
      を選択肢して実行可能です。</p>
      <figure>
      <img src="figs/03/vscode_01.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p>特にReact開発の場面では、<code>import</code> 文で <span
      class="masked">適切にファイルパスを設定しているにも関わらず「赤波線」でエラーが表示されること</span>
      があります。そのようなときは、この <strong>再読み込み操作</strong>
      で解決します。</p>
      <h2 data-number="2.2" id="ファイルパス補完の拡張機能"><span
      class="header-section-number">2.2</span>
      ファイルパス補完の拡張機能</h2>
      <p>VSCodeの拡張機能として <strong>Path Intellisense</strong>
      (識別子:<code>christian-kohler.path-intellisense</code>)
      をインストールしておくと、プログラムのなかで
      <strong>ファイルパス</strong>
      を入力するときに補完が有効になって便利です。</p>
      <p>ファイルパス補完の拡張機能は「Path
      Intellisense」の他にも様々なものがあるので、自分で使いやすいものを探してみてください。</p>
      <h2 data-number="2.3" id="react開発の支援機能"><span
      class="header-section-number">2.3</span> React開発の支援機能</h2>
      <p>React関連のコードスニペットを挿入する拡張機能として
      <strong>ES7+React/Redux/Reac1t-Native snippets</strong> (識別子:
      <code>dsznajder.es7-react-js-snippets</code>) を VScode
      にインストールしておいてください
      (次回以降の講義では、この拡張機能がインストールされている前提で解説します)。</p>
      <p>この拡張機能を入れると <code>rafce</code>
      と入力するだけで、<strong>Reactコンポーネントのスニペット</strong>
      (=プログラムコードの定型的な断片、雛形)
      をエディタに挿入してくれます。</p>
      <figure>
      <img src="figs/03/vscode_04.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p>この拡張機能の概要は<a
      href="https://www.google.com/search?q=ES7%2BReact%2FRedux%2FReac1t-Native+snippets+おすすめ">こちら</a>を参照してください。</p>
      <h2 data-number="2.4" id="コードチェックツールの拡張機能"><span
      class="header-section-number">2.4</span>
      コードチェックツールの拡張機能</h2>
      <p><strong>ESLint</strong> (識別子:
      <code>dbaeumer.vscode-eslint</code>) は、ECMAScript用
      (=TypeScript/JavaScript用) の
      <strong>コードチェックツール</strong>
      に関する拡張機能です。こちらも、次回以降の講義で利用していく予定なのであらかじめインストールしておいてください。</p>
      <p>この拡張機能の概要は<a
      href="https://www.google.com/search?q=vscode+拡張機能+eslint">こちら</a>を参照してください。</p>
      <h2 data-number="2.5" id="tailwind用のインテリセンス"><span
      class="header-section-number">2.5</span>
      Tailwind用のインテリセンス</h2>
      <p><strong>Tailwind CSS IntelliSense</strong> (識別子
      <code>bradlc.vscode-tailwindcss</code>) は<a
      href="https://www.google.com/search?q=Tailwind+入門">Tailwind
      CSS</a>という CSSフレームワークに関連したインテリセンス
      (コードの自動補完ツール) です。本授業でのウェブアプリ開発でも
      Tailwind CSS
      を使用していくので、その開発体験を向上させるためにインストールしておいてください。</p>
      <p>この拡張機能の概要は<a
      href="https://www.google.com/search?q=Tailwind+CSS+IntelliSense+おすすめ">こちら</a>を参照してください。</p>
      <h1 data-number="3" id="前回の復習"><span
      class="header-section-number">3</span> 前回の復習:</h1>
      <h2 data-number="3.1"
      id="オブジェクトのプロパティを変更ための2つのアプローチ"><span
      class="header-section-number">3.1</span>
      オブジェクトのプロパティを変更ための2つのアプローチ</h2>
      <p>前回の講義では、ユーザー定義型の
      <strong>オブジェクトを更新</strong>する場合
      (主に<strong>オブジェクトのプロパティ(属性)を変更</strong>する場合)
      には <span class="masked">似て非なる2つの方法 (アプローチ)
      が存在すること</span> を解説しました。</p>
      <h3 data-number="3.1.1" id="ミュータブルなオブジェクト更新"><span
      class="header-section-number">3.1.1</span>
      ミュータブルなオブジェクト更新</h3>
      <p>1つめに示したものは、次のように
      <strong>オブジェクトの属性を直接的に変更する方法</strong>
      でした。</p>
      <div class="sourceCode" id="cb1"
      data-caption="mutableApproach.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">export</span> {}</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">const</span> todo<span class="op">:</span> Todo <span class="op">=</span> {</span>
<span id="cb1-5"><a href="#cb1-5"></a>  name<span class="op">:</span> <span class="st">&quot;Learn TypeScript&quot;</span><span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  priority<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">45</span>)<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>}<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">// ▼▼▼ ここから</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">const</span> updatedTodo <span class="op">=</span> todo<span class="op">;</span> <span class="co">// ➊</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>updatedTodo<span class="op">.</span><span class="at">name</span> <span class="op">=</span> <span class="st">&quot;Learn COBOL&quot;</span><span class="op">;</span> <span class="co">// ➋</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>updatedTodo<span class="op">.</span><span class="at">priority</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// ➌</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">// ▲▲▲ ここまでが着目してほしいところ</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co">// updatedTodo と todo の「参照」は同じ (=同じオブジェクト)</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;todo !== updatedTodo ---&gt; &quot;</span> <span class="op">,</span>todo <span class="op">!==</span> updatedTodo)<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co">// todo の内容を確認</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;■ todo の内容&quot;</span>)</span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(todo<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co">// updatedTodoの内容を確認</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;■ updatedTodoの内容&quot;</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodo<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。</p>
      <pre><code>todo !== updatedTodo ---&gt;  false
■ todo の内容
{
  &quot;name&quot;: &quot;Learn COBOL&quot;,
  &quot;priority&quot;: 1,
  &quot;isDone&quot;: false,
  &quot;deadline&quot;: &quot;2024-10-11T00:45:00.000Z&quot;
}
■ updatedTodoの内容
{
  &quot;name&quot;: &quot;Learn COBOL&quot;,
  &quot;priority&quot;: 1,
  &quot;isDone&quot;: false,
  &quot;deadline&quot;: &quot;2024-10-11T00:45:00.000Z&quot;
}</code></pre>
      <p><code>mutableApproach.ts</code> の <strong>第12行目
      (➊)</strong> の <code>updatedTodo = todo</code> は、いわゆる <span
      class="masked">浅いコピー (Shallow Copy)</span>
      であり、<code>todo</code> の <strong>参照</strong>
      (C言語で言えば<strong>ポインタ</strong>、Pythonで言えば<strong>オブジェクトID</strong>のようなもの)
      を、<code>updatedTodo</code>
      に複製した<strong>だけ</strong>に相当します。</p>
      <figure>
      <img src="figs/03/obj_01.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p>そのため、<strong>第13行目 (❷)</strong> と <strong>第14行目
      (➌)</strong> は <code>updatedTodo</code>
      を対象に操作しているように見えますが、実際のところ、それは
      <code>todo</code>
      の参照先を変更していることにもなります。そのため、実行結果を確認すると
      <code>todo</code> の <code>name</code> も <span
      class="masked">Learn COBOL</span> に変更されています。</p>
      <p>このようにオリジナルのデータ (<code>todo</code>)
      のプロパティを上書きすることから、このようなアプローチは「<strong>状態直接操作</strong>」や「<strong>破壊的更新</strong>」、「<strong>ミュータブルなオブジェクト更新</strong>」のように呼ばれます。</p>
      <p>この授業のなかでは、このようなオブジェクトの操作を <span
      class="masked">「ミュータブルなオブジェクト更新」</span>
      のように表現してきます。<strong>ミュータブル (Mutable)</strong>
      とは「可変な」「変更可能な」という意味になります。</p>
      <h3 data-number="3.1.2"
      id="イミュータブルなオブジェクト更新"><span
      class="header-section-number">3.1.2</span>
      イミュータブルなオブジェクト更新</h3>
      <p>前回授業では、上記で示したミュータブルなオブジェクト更新とは<strong>別に</strong>、次のように「<strong>スプレッド構文</strong>」を使って<a
      href="lecture02.html#reactが変更を検知可能なオブジェクトの生成">プロパティを更新した新たなオブジェクトを生成する方法</a>も解説しました。</p>
      <div class="sourceCode" id="cb3"
      data-caption="immutableApproach.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">export</span> {}</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">const</span> todo<span class="op">:</span> Todo <span class="op">=</span> {</span>
<span id="cb3-5"><a href="#cb3-5"></a>  name<span class="op">:</span> <span class="st">&quot;Learn TypeScript&quot;</span><span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  priority<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>  isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>  deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">45</span>)<span class="op">,</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>}<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">// ▼▼▼ ここから</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="kw">const</span> updatedTodo <span class="op">=</span> {</span>
<span id="cb3-13"><a href="#cb3-13"></a>  <span class="op">...</span>todo<span class="op">,</span> <span class="co">// スプレッド構文</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>  name<span class="op">:</span> <span class="st">&quot;Learn COBOL&quot;</span><span class="op">,</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>  priority<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>}<span class="op">;</span> <span class="co">// ➊～➌</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">// ▲▲▲ ここまでが着目してほしいところ</span></span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">// updatedTodo と todo の「参照」は違う (=異なるオブジェクト)</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;todo !== updatedTodo ---&gt; &quot;</span> <span class="op">,</span>todo <span class="op">!==</span> updatedTodo)<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co">// todo の内容を確認</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;■ todo の内容&quot;</span>)</span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(todo<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="co">// updatedTodo の内容を確認</span></span>
<span id="cb3-27"><a href="#cb3-27"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;■ updatedTodoの内容&quot;</span>)</span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodo<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。</p>
      <pre><code>todo !== updatedTodo ---&gt;  true
■ todo の内容
{
  &quot;name&quot;: &quot;Learn TypeScript&quot;,
  &quot;priority&quot;: 3,
  &quot;isDone&quot;: false,
  &quot;deadline&quot;: &quot;2024-10-11T00:45:00.000Z&quot;
}
■ updatedTodoの内容
{
  &quot;name&quot;: &quot;Learn COBOL&quot;,
  &quot;priority&quot;: 1,
  &quot;isDone&quot;: false,
  &quot;deadline&quot;: &quot;2024-10-11T00:45:00.000Z&quot;
}</code></pre>
      <p>この方法は、以下の図に示すように、オリジナルのデータ
      (<code>todo</code>)
      は変化させずに、別途、<strong>プロパティを変更した新しいオブジェクト</strong>
      (<code>updatedTodo</code>) を作成するアプローチであり、<span
      class="masked">「イミュータブルなオブジェクト更新」</span>
      のように呼ばれます。新しいオブジェクトが生成された証拠に、<strong>第20行目</strong>
      の出力は <span class="masked"><code>true</code></span>
      となります。</p>
      <p>先ほどの <strong>ミュータブル (Mutable)</strong>
      に対して、<strong>イミュータブル (Immutable)</strong>
      とは「変更できない」「不変」という意味になります。余談ですが、ミュータブル
      / イミュータブル
      などの考え方は「<strong>Haskell</strong>」や「<strong>Scala</strong>」などの<a
      href="https://ja.wikipedia.org/wiki/関数型プログラミング">関数型プログラミング</a>で重要な概念となってきます。</p>
      <figure>
      <img src="figs/03/obj_02.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p><code>ImmutableApproach.ts</code> の <strong>第12行目</strong>
      から <strong>第16行目</strong>
      の処理は、以下のコードと<strong>等価</strong>となります。</p>
      <div class="sourceCode" id="cb5"
      data-caption="immutableApproach.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">const</span> updatedTodo <span class="op">=</span> {</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="op">...</span>todo<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>}<span class="op">;</span> <span class="co">// ➊</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>updatedTodo<span class="op">.</span><span class="at">name</span> <span class="op">=</span> <span class="st">&quot;Learn COBOL&quot;</span><span class="op">;</span> <span class="co">// ➋</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>updatedTodo<span class="op">.</span><span class="at">priority</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// ➌</span></span></code></pre></div>
      <p>なお、スプレッド構文は、Pythonにおける<a
      href="https://takeshiwada1980.github.io/Programming1-2023/lecture12.html#リストの扱いに関する補足②-アンパック">アンパック</a>のようなものとイメージしてください。それでも、イメージがつかみづらいときは「生成AI」を利用してみてください。</p>
      <blockquote>
      <p>JavaScriptにおける「スプレッド構文」のイメージがつかめません。特に「イミュータブルなオブジェクト更新」のために、スプレッド構文を使うという解説を聞いたのですがしっくりきません。具体的なコードを示して分かりやすく解説してください。</p>
      </blockquote>
      <h2 data-number="3.2"
      id="react開発ではイミュータブルなオブジェクト更新を使用"><span
      class="header-section-number">3.2</span>
      React開発では「イミュータブルなオブジェクト更新」を使用</h2>
      <p><a
      href="lecture02.html#reactにおける状態-オブジェクト-の変更の検知-概要">前回授業</a>で解説したように、Reactを使ったフロントエンド開発において「<strong>オブジェクトのプロパティを変更するとき</strong>」は、原則として
      <span
      class="masked">スプレッド構文を利用したイミュータブルなオブジェクト更新</span>
      を使用するように意識してください。</p>
      <p>なぜならば、<strong>React</strong>
      では「<strong>オブジェクトの参照が (以前と)
      変化しているかどうか</strong>」に基づいて<span
      class="masked">画面表示を更新するかどうか
      (再レンダリング・再描画するか) を判断・最適化</span>
      しているためです。適切に画面が再レンダリングされなければ、内部的にデータが書き換わっていても、利用者が見ている画面上にはそれが反映されていないという困った状態になります。</p>
      <p>このようなことから、Reactを使った開発では
      <strong>イミュータブルなオブジェクト更新を原則</strong>
      とする必要があります。以下は、<span
      class="masked">Reactにおける画面更新の基本的な流れと仕組み</span>
      になります。</p>
      <ol type="1">
      <li>イミュータブルな操作によって新しいオブジェクトを生成する。</li>
      <li>新しく生成されたオブジェクトは、元のオブジェクトとは
      <strong>異なる参照</strong>（C言語でいえばポインタ、Pythonで言えばオブジェクトID）を持つ。</li>
      <li>新しく生成されたオブジェクトをReactの <strong>状態
      (state)</strong> にセットする (主に <a
      href="https://www.google.com/search?q=useStateとは">useStateフック</a>
      を利用)、あるいは、子コンポーネントの<a
      href="https://www.google.com/search?q=React+propsとは">Props</a>(プロップス)
      に渡す。
      <ul>
      <li><code>useState</code> や <code>Props</code>
      については次回以降に詳しく学びます。</li>
      </ul></li>
      <li>Reactは、Pros や state にセットされた
      <strong>オブジェクトの参照の変化</strong>
      を検知し、画面の再レンダリング (<a
      href="https://www.google.com/search?q=DOM操作">DOM操作</a>)
      をする。</li>
      </ol>
      <p>なお、今回講義では「<strong>配列</strong>」を学びますが、配列についても「ミュータブルな更新」と「イミュータブルな更新」が存在します。こちらも同様に「<strong>イミュータブルな配列更新</strong>」をする必要があります
      (React開発の前提で)。</p>
      <h3 data-number="3.2.1" id="演習①"><span
      class="header-section-number">3.2.1</span> 演習①</h3>
      <p>イミュータブルなオブジェクト更新によって、期限を
      <code>Date(2024, 9, 30)</code>、完了フラグを <code>true</code>
      に変更したオブジェクトを <code>updatedTodo</code>
      に得るようにプログラムを追記してください。また、実際に結果を確認してください。</p>
      <ul>
      <li>ここではスプレッド構文を利用することを期待しています。</li>
      </ul>
      <div class="sourceCode" id="cb6" data-caption="演習 (1)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">import</span> { printTodo } <span class="im">from</span> <span class="st">&quot;./utils/printTodo&quot;</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="im">import</span> assert <span class="im">from</span> <span class="st">&quot;assert&quot;</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">const</span> todo<span class="op">:</span> Todo <span class="op">=</span> {</span>
<span id="cb6-7"><a href="#cb6-7"></a>  name<span class="op">:</span> <span class="st">&quot;Learn TypeScript&quot;</span><span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>  priority<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>  deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">45</span>)<span class="op">,</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>}<span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">// ここを編集</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">// const updatedTodo =</span></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">// todo と updatedTodo の参照が「異なること」を念のために確認</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>assert<span class="op">.</span><span class="fu">notEqual</span>(todo<span class="op">,</span> updatedTodo)<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co">// updatedTodo の内容を確認</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="fu">printTodo</span>(updatedTodo)<span class="op">;</span></span></code></pre></div>
      <ul>
      <li><p><strong>第17行目</strong>の <code>assert</code> は、PG1の<a
      href="https://takeshiwada1980.github.io/Programming1-2023/lecture11.html#アサート文">第11回講義</a>で学んだPythonの「アサート」と同じです。</p>
      <ul>
      <li><code>npm install</code>
      コマンドで追加しなくても標準で利用可能です。</li>
      <li><code>assert.notEqual(todo, updatedTodo)</code>
      は、<code>todo</code> と <code>updatedTodo</code>
      の参照が異なるときは何もせず、参照が同じときには例外 (Error)
      を発生させます。</li>
      </ul></li>
      <li><p><code>utils/printTodo.ts</code> で定義している
      <code>printTodo</code> 関数について、<strong>完了フラグ
      (</strong><code>isDone</code><strong>)
      の内容が表示されるようにアップデート</strong>
      してください。</p></li>
      <li><p>解答例は<a
      href="https://github.com/TakeshiWada1980/Programming3-2024/blob/main/docs/codes/03/code01.ts">こちら<i class="fa-solid fa-person-chalkboard"></i></a></p></li>
      </ul>
      <h1 data-number="4" id="配列"><span
      class="header-section-number">4</span> 配列</h1>
      <p>ここからは <strong>配列 (Array)</strong> と、その操作 (特に
      <strong>イミュータブルな配列更新</strong>) について学びます。</p>
      <h2 data-number="4.1" id="導入"><span
      class="header-section-number">4.1</span> 導入</h2>
      <p><a
      href="lecture02.html#オブジェクトの型定義">前回講義</a>で定義した
      <code>Todo</code>
      型のような「<strong>ユーザ定義型の配列</strong>」は、Reactにおけるコアなデータとなります。また、その配列に対する操作
      (<code>map</code>、<code>filter</code>、<code>sort</code> など)
      は、Reactによる画面描画と密接に関係してきます。</p>
      <p>例えば、<a
      href="https://takeshiwada1980.github.io/react-todo-app-demo/">Todoアプリ</a>に表示される次のような
      <strong>コンポーネント (画面構成の部品)</strong> は…</p>
      <figure>
      <img src="figs/03/app_01.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p>以下のような <strong>Todo型の配列</strong>
      (<code>Todo[]</code>) のデータに基づいて描画されます。</p>
      <div class="sourceCode" id="cb7" data-caption="initTodos.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="im">import</span> { v4 <span class="im">as</span> uuid } <span class="im">from</span> <span class="st">&quot;uuid&quot;</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="im">export</span> <span class="kw">const</span> initTodos<span class="op">:</span> Todo[] <span class="op">=</span> [</span>
<span id="cb7-5"><a href="#cb7-5"></a>  {</span>
<span id="cb7-6"><a href="#cb7-6"></a>    id<span class="op">:</span> <span class="fu">uuid</span>()<span class="op">,</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    name<span class="op">:</span> <span class="st">&quot;Reactの勉強 (予習)&quot;</span><span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    priority<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    deadline<span class="op">:</span> <span class="dt">undefined</span><span class="op">,</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>  }<span class="op">,</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>  {</span>
<span id="cb7-13"><a href="#cb7-13"></a>    id<span class="op">:</span> <span class="fu">uuid</span>()<span class="op">,</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    name<span class="op">:</span> <span class="st">&quot;TypeScriptの勉強 (復習)&quot;</span><span class="op">,</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>    isDone<span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>    priority<span class="op">:</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>    deadline<span class="op">:</span> <span class="dt">undefined</span><span class="op">,</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>  }<span class="op">,</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>  {</span>
<span id="cb7-20"><a href="#cb7-20"></a>    id<span class="op">:</span> <span class="fu">uuid</span>()<span class="op">,</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>    name<span class="op">:</span> <span class="st">&quot;基礎物理学3の宿題&quot;</span><span class="op">,</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>    isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>    priority<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">11</span>)<span class="op">,</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>  }<span class="op">,</span></span>
<span id="cb7-26"><a href="#cb7-26"></a>  {</span>
<span id="cb7-27"><a href="#cb7-27"></a>    id<span class="op">:</span> <span class="fu">uuid</span>()<span class="op">,</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>    name<span class="op">:</span> <span class="st">&quot;解析2の宿題&quot;</span><span class="op">,</span></span>
<span id="cb7-29"><a href="#cb7-29"></a>    isDone<span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>    priority<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-31"><a href="#cb7-31"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">17</span>)<span class="op">,</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>  }<span class="op">,</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>]<span class="op">;</span></span></code></pre></div>
      <p>そして「ボタン押下」などの操作を受けて、<code>todos</code>
      に要素の追加や削除をしたり、要素のプロパティを変更した
      <code>updatedTodos</code>
      を生成し、それをReactに渡すと、React側で再レンダリング
      (画面の更新) が実行されます。この際、Reactは <span
      class="masked">変更があった部分のみを検出して効率的に差分だけを再描画</span>
      をします。</p>
      <p>ただし、ここで注意すべきは「Reactが配列やその要素であるオブジェクトのプロパティの更新を検知可能な形で
      <code>todos</code> から <code>updatedTodos</code>
      を生成する必要があること」です。</p>
      <h2 data-number="4.2" id="型と宣言"><span
      class="header-section-number">4.2</span> 型と宣言</h2>
      <p>まずは、シンプルに数値型や文字列型などの<a
      href="https://developer.mozilla.org/ja/docs/Glossary/Primitive">プリミティブデータ</a>の「配列」から学んでいきます。TypeScript
      では、次のように C言語ライクに 配列 (Array)
      を宣言・初期化します。</p>
      <div class="sourceCode" id="cb8"
      data-caption="prac05.ts (配列の宣言と初期化)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">// 配列の初期化 (型明示)</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">const</span> numArr1<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">4649</span><span class="op">,</span> <span class="dv">3150</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">const</span> strArr1<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> [<span class="st">&quot;M&quot;</span><span class="op">,</span> <span class="st">&quot;D&quot;</span><span class="op">,</span> <span class="st">&quot;E&quot;</span><span class="op">,</span> <span class="st">&quot;知能情報&quot;</span>]<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">// 配列の初期化 (型推論)</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">const</span> numArr2 <span class="op">=</span> [<span class="dv">4649</span><span class="op">,</span> <span class="dv">3150</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">const</span> strArr2 <span class="op">=</span> [<span class="st">&quot;M&quot;</span><span class="op">,</span> <span class="st">&quot;D&quot;</span><span class="op">,</span> <span class="st">&quot;E&quot;</span><span class="op">,</span> <span class="st">&quot;知能情報&quot;</span>]<span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">// 空配列の初期化 (型明示が必ず必要)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">const</span> numArr3<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">const</span> strArr3<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> []<span class="op">;</span></span></code></pre></div>
      <p>配列を使用するときは、宣言時に <span
      class="masked"><code>number[]</code></span> あるいは
      <code>Array&lt;number&gt;</code> のように「<strong>型
      (Type)</strong>」を指示します。
      どちらも同じ意味になりますが、一般には <code>xxx[]</code>
      の形式が使われます。</p>
      <p>TypeScriptの配列は、<strong>基本的に同じ型の値</strong>
      を要素に持つような使い方をします。ただし、次の
      <strong>第04行目</strong> のように型を
      <code>(number | string)[]</code> とすれば、<span
      class="masked">数値型または文字列型を要素に持つ配列</span>
      も可能です。</p>
      <div class="sourceCode" id="cb9" data-caption="prac05.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">// 「数値型」または「文字列型」を要素に持つ配列</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">const</span> arr1<span class="op">:</span> (<span class="dt">number</span> <span class="op">|</span> <span class="dt">string</span>)[] <span class="op">=</span> [<span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span></code></pre></div>
      <h2 data-number="4.3"
      id="参考-要素の追加と削除-ミュータブルな配列操作"><span
      class="header-section-number">4.3</span> 参考: 要素の追加と削除
      (ミュータブルな配列操作)</h2>
      <p><strong>React開発では基本的に使用ことはありませんが</strong>、ミュータブルな配列要素の「追加」と「削除」の例を示しておきます。このプログラムでは、配列が持つ
      <code>push</code>、<code>unshift</code>、<code>splice</code>、<code>pop</code>
      などのメソッドを使っていますが、<span
      class="masked">これらを本授業の範囲で使用する場面は (おそらく)
      ありません</span>。</p>
      <div class="sourceCode" id="cb10"
      data-caption="prac05.ts (Reactでは基本的に使用しないミュータブルな配列操作)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb10-1"><a href="#cb10-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">const</span> numArr<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">10</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">13</span>]<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;初期状態 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>numArr<span class="op">.</span><span class="fu">push</span>(<span class="dv">14</span>)<span class="op">;</span> <span class="co">// 末尾に要素を追加</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>numArr<span class="op">.</span><span class="fu">unshift</span>(<span class="dv">9</span>)<span class="op">;</span> <span class="co">// 先頭に要素を追加</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;先頭と末尾に要素を追加した後 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="co">// 2番目に要素(10.5)を挿入 ゼロオリジンに注意</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>numArr<span class="op">.</span><span class="fu">splice</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">10.5</span>)<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;2番目の位置に要素を挿入した後 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>numArr<span class="op">.</span><span class="fu">pop</span>()<span class="op">;</span> <span class="co">// 末尾の要素を削除</span></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;末尾の要素を削除した後 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="co">// 4番目の要素を削除</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>numArr<span class="op">.</span><span class="fu">splice</span>(<span class="dv">4</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;4番目の位置の要素を削除した後 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。</p>
      <pre><code>初期状態 =&gt; 10,11,12,13
先頭と末尾に要素を追加した後 =&gt; 9,10,11,12,13,14
2番目の位置に要素を挿入した後 =&gt; 9,10,10.5,11,12,13,14
末尾の要素を削除した後 =&gt; 9,10,10.5,11,12,13
4番目の位置の要素を削除した後 =&gt; 9,10,10.5,11,13</code></pre>
      <h2 data-number="4.4" id="要素の追加-イミュータブルな変更"><span
      class="header-section-number">4.4</span> 要素の追加
      (イミュータブルな変更)</h2>
      <p>React開発では、<code>push</code> や
      <code>pop</code>、<code>splice</code>
      などのメソッドを<strong>使用せず</strong>に、<strong>配列に対してイミュータブルな操作をすること</strong>
      が要求されます。</p>
      <p>配列に対する <span class="masked">要素の追加</span>
      に関しては、次のように「<strong>スプレッド構文</strong>」を利用してイミュータブルな操作
      (=元の配列には変更を加えずに、「変更を適用した新しい配列」を生成すること)
      が可能です。</p>
      <div class="sourceCode" id="cb12" data-caption="prac05.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">const</span> numArr<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">10</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">13</span>]<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;初期状態 =&gt; &quot;</span> <span class="op">+</span> numArr)<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">// 末尾に要素を追加</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">const</span> addedToEnd <span class="op">=</span> [<span class="op">...</span>numArr<span class="op">,</span> <span class="dv">14</span>]<span class="op">;</span> <span class="co">// スプレッド構文</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;末尾に要素を追加 =&gt; &quot;</span> <span class="op">+</span> addedToEnd)<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co">// 先頭に要素を追加</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="kw">const</span> addedToStart <span class="op">=</span> [<span class="dv">9</span><span class="op">,</span> <span class="op">...</span>numArr]<span class="op">;</span> <span class="co">// スプレッド構文</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;先頭に要素を追加 =&gt; &quot;</span> <span class="op">+</span> addedToStart)<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="co">// n番目の位置に要素 (10.5) を挿入</span></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="kw">const</span> n <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="kw">const</span> insertedAtN <span class="op">=</span> [<span class="op">...</span>numArr<span class="op">.</span><span class="fu">slice</span>(<span class="dv">0</span><span class="op">,</span> n)<span class="op">,</span> <span class="fl">10.5</span><span class="op">,</span> <span class="op">...</span>numArr<span class="op">.</span><span class="fu">slice</span>(n)]<span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`</span><span class="sc">${</span>n<span class="sc">}</span><span class="vs">番目の位置に要素を挿入 =&gt; `</span> <span class="op">+</span> insertedAtN)<span class="op">;</span></span></code></pre></div>
      <p><strong>第16行目</strong>
      では「配列の途中位置に要素を追加する例」を示していますが、実際の開発では、<span
      class="masked">末尾か先頭に要素を追加したうえで
      <code>sort()</code> メソッドを使って並び替えすること</span>
      が多いです。よって、特に覚えるべき処理は、<strong>スプレッド構文を利用して「先頭」または「末尾」に要素を追加する処理</strong>
      になります。</p>
      <p>配列要素の「削除」については、後ほど解説する
      <code>filter()</code> メソッドを利用します。</p>
      <div class="note type-tips">
      <p><strong><code>splice</code> と <code>slice</code>
      の違い</strong></p>
      <p>配列操作の <code>splice</code> メソッド と <code>slice</code>
      メソッドは機能と使用方法が異なるので注意してください。興味がある人は、生成AIを使用して調べてみてください。</p>
      <blockquote>
      <p>JavaScriptの配列の <code>splice</code> メソッド と
      <code>slice</code>
      メソッドの違いをミュータブル、イミュータブルの観点から説明してください。</p>
      </blockquote>
      </div>
      <h2 data-number="4.5" id="map-による要素の更新"><span
      class="header-section-number">4.5</span> map による要素の更新</h2>
      <p>モダンTypeScriptにおいて
      <strong>イミュータブルに配列要素を更新</strong>
      するためには、一般に <span class="masked">「アロー関数」と「map()
      メソッド」</span>
      を組み合わせて使用します。これは、プログラミング1 (Python)
      で学んだ「<a
      href="https://takeshiwada1980.github.io/Programming1-2023/lecture19.html#ラムダ式">ラムダ式</a>と<a
      href="ht%20tps://takeshiwada1980.github.io/Programming1-2023/lecture19.html#mapとラムダ式の組み合わせ">map関数</a>の<strong>組み合わせ</strong>」に相当するものです。</p>
      <p>例えば、「学年」を表す数値型の配列 <code>grade</code>
      から、HTML用に整形した文字列の配列 <code>gradeListItems</code>
      を得るためのイミュータブルな操作は、次のように記述できます。</p>
      <div class="sourceCode" id="cb13" data-caption="prac06.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span> <span class="co">// 学年</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">// ▼▼▼ ここから</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>((grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> <span class="kw">=&gt;</span> {</span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="cf">return</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>})<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="co">// ▲▲▲ ここまでが着目してほしいところ</span></span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(grades)<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(gradeListItems)<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。配列の要素が <code>1</code>
      から <code>'&lt;li&gt;1年&lt;/li&gt;'</code>
      のように変換されていること (mapされていること、射影されていること)
      が確認できると思います
      (特定の要素だけに変換を適用する方法については後述します)。</p>
      <pre><code>[ 1, 2, 3, 4, 5 ]
[
  &#39;&lt;li&gt;1年&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;2年&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;3年&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;4年&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;5年&lt;/li&gt;&#39;
]</code></pre>
      <p>処理の本質は
      <strong>第06行目</strong>から<strong>第08行目</strong>
      になりますが初見で読み解くことは <strong>かなり難しい</strong>
      と思います。これを読み解き、理解するために「<strong>レガシーな手続き型スタイルの配列操作</strong>」から、上記のような「<strong>モダンな宣言型スタイルの配列操作</strong>」に書き換える例を以下に示します。</p>
      <h3 data-number="4.5.1"
      id="第1形態-レガシーな手続き型スタイル"><span
      class="header-section-number">4.5.1</span> 第1形態 :
      レガシーな手続き型スタイル</h3>
      <p>まず、従来型の書き方をすれば、以下のようになります。既に皆さんは「C言語」を学んできているので、十分に読み解くことができると思います。</p>
      <div class="sourceCode" id="cb15"
      data-caption="prac06.ts (第1形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">const</span> gradeListItems<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> []<span class="op">;</span> <span class="co">// 要素が空の配列</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> grades<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="kw">const</span> listItem <span class="op">=</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grades[i]<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  gradeListItems<span class="op">.</span><span class="fu">push</span>(listItem)<span class="op">;</span> <span class="co">// 要素を追加</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>}</span></code></pre></div>
      <p>ここでは簡略化のために <code>export {};</code> と
      <code>console.log(...)</code>
      の部分は省略しています。実際に動作確認する際には、それらを追加して実行してください。</p>
      <p>なお、配列は、<code>length</code>
      プロパティを持ち、それを通して配列の要素数を得ることができます。例えば、<code>const grades = [1, 2, 3, 4];</code>
      の <code>grades.length</code> は <span class="masked">4</span>
      となります。</p>
      <h3 data-number="4.5.2" id="第2形態-forof-に書き換え"><span
      class="header-section-number">4.5.2</span> 第2形態 : for…of
      に書き換え</h3>
      <p><code>for</code>
      の<strong>ループ変数</strong>を「配列のインデックス<code>i</code>」から「配列の要素そのもの<code>grade</code>」に変えました。<strong>第03行目</strong>
      と <strong>第04行目</strong>
      を書き換えていますが、実行結果は先ほどと同じく期待する出力を得ることができます。</p>
      <div class="sourceCode" id="cb16"
      data-caption="prac06.ts (第2形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">const</span> gradeListItems<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="cf">for</span> (<span class="kw">const</span> grade <span class="kw">of</span> grades) { <span class="co">// ■■ ここを書き換えた ■■ </span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  <span class="kw">const</span> listItem <span class="op">=</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span> <span class="co">// ■■ ここを書き換えた ■■ </span></span>
<span id="cb16-5"><a href="#cb16-5"></a>  gradeListItems<span class="op">.</span><span class="fu">push</span>(listItem)<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>}</span></code></pre></div>
      <p>なお、<code>for (const grade of grades)</code>
      によって、ループ毎に変数 <code>grade</code> のなかには
      <code>1</code>、<code>2</code>、<code>3</code>…
      という値が格納されます。もし、<strong>第01行目</strong> で
      <code>const grades = [9, 1, 5]</code>
      としていれば、ループ変数である <code>grade</code> には、ループ毎に
      <code>9</code>、<code>1</code>、<code>5</code>
      という値が格納されてfor文の内部の処理が実行されます。</p>
      <p>Python で書けば <code>for grade in grades:</code> ですね (<a
      href="https://takeshiwada1980.github.io/Programming1-2023/lecture08.html#pythonicなリストとfor文の組み合わせ">参照</a>)。</p>
      <h3 data-number="4.5.3" id="第3形態-変換処理の関数化"><span
      class="header-section-number">4.5.3</span> 第3形態 :
      変換処理の関数化</h3>
      <p>数値型の値 (例えば <code>3</code> ) を、整形された文字列型の値
      (例えば <code>"&lt;li&gt;3年&lt;/li&gt;"</code>)
      に変換するための処理を <code>func</code>
      として分離しました。また、<strong>第08行目</strong> で、それを
      <code>func(grade)</code> にように呼び出しています。</p>
      <div class="sourceCode" id="cb17"
      data-caption="prac06.ts (第3形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">function</span> <span class="fu">func</span>(grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> {</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="cf">return</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>}</span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">const</span> gradeListItems<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="cf">for</span> (<span class="kw">const</span> grade <span class="kw">of</span> grades) {</span>
<span id="cb17-8"><a href="#cb17-8"></a>  gradeListItems<span class="op">.</span><span class="fu">push</span>(<span class="fu">func</span>(grade))<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>}</span></code></pre></div>
      <h3 data-number="4.5.4" id="第4形態-アロー関数化"><span
      class="header-section-number">4.5.4</span> 第4形態 :
      アロー関数化</h3>
      <p>「function関数」を「アロー関数」に書き換えました。<strong>第01行目</strong>
      だけを書き換えました。</p>
      <div class="sourceCode" id="cb18"
      data-caption="prac06.ts  (第4形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">const</span> func <span class="op">=</span> (grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> <span class="kw">=&gt;</span> { <span class="co">// ■■ アロー関数化 ■■ </span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="cf">return</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>}<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="kw">const</span> gradeListItems<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="cf">for</span> (<span class="kw">const</span> grade <span class="kw">of</span> grades) {</span>
<span id="cb18-8"><a href="#cb18-8"></a>  gradeListItems<span class="op">.</span><span class="fu">push</span>(<span class="fu">func</span>(grade))<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>}</span></code></pre></div>
      <h3 data-number="4.5.5" id="第5形態-mapメソッドの利用"><span
      class="header-section-number">4.5.5</span> 第5形態 :
      mapメソッドの利用</h3>
      <p><code>for</code> を使って実行していた処理を、<code>map</code>
      を使った処理に書き換えました。第4形態の <strong>第06行目</strong>
      から <strong>第09行目</strong> までの処理が、ここでは
      <strong>第05行目</strong>
      の「1文だけ」でスッキリと記述できています。</p>
      <div class="sourceCode" id="cb19"
      data-caption="prac06.ts (第5形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">const</span> func <span class="op">=</span> (grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> <span class="kw">=&gt;</span> {</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="cf">return</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>}<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>(func)<span class="op">;</span> <span class="co">// ■■ 注目 ■■ </span></span></code></pre></div>
      <p><code>map()</code> は
      <strong>元の配列を変更せず</strong>、配列の各要素に
      <code>func</code>
      を適用した「新しい配列」を作成して戻り値とします。これは、React開発で重要となってくる特性なので覚えておいてください。</p>
      <h3 data-number="4.5.6"
      id="第6形態-mapの引数に直接的にアロー関数を記述"><span
      class="header-section-number">4.5.6</span> 第6形態 :
      mapの引数に直接的にアロー関数を記述</h3>
      <p>第5形態では、<span class="masked">変数 <code>func</code></span>
      を経由して、mapメソッドの引数に「整形の処理」を与えていました。それを、ここではアロー関数の形式で
      <strong>直接的</strong> に与えるように書き換えました。</p>
      <div class="sourceCode" id="cb20"
      data-caption="prac06.ts (第6形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>((grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> <span class="kw">=&gt;</span> {</span>
<span id="cb20-3"><a href="#cb20-3"></a>  <span class="cf">return</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>})<span class="op">;</span></span></code></pre></div>
      <p>ここでは、整形処理をする関数に名前を与える必要がないこともうれしいですね（適切な名前を考えるのは面倒ですから…）。</p>
      <p>ここまでで、最初に示したモダンスタイルな配列処理に変換が完了しました。</p>
      <h3 data-number="4.5.7" id="第7形態-省略形"><span
      class="header-section-number">4.5.7</span> 第7形態 (省略形)</h3>
      <p>アロー関数のなかの処理が <code>return ...;</code>
      の1文だけで構成できる場合は、以下のように「<strong>波括弧</strong>」と「<code>retuen</code>」を省略して書くこともできます。</p>
      <div class="sourceCode" id="cb21"
      data-caption="prac06.ts (第7形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>((grade<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">string</span> <span class="kw">=&gt;</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>)<span class="op">;</span></span></code></pre></div>
      <h3 data-number="4.5.8" id="第8形態-型推論を利用"><span
      class="header-section-number">4.5.8</span> 第8形態
      (型推論を利用)</h3>
      <p>型推論ができる場合は、型を省略することができます。</p>
      <div class="sourceCode" id="cb22"
      data-caption="prac06.ts (第8形態)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>((grade) <span class="kw">=&gt;</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span>)<span class="op">;</span></span></code></pre></div>
      <p>最終的には、次のように記述できます。</p>
      <div class="sourceCode" id="cb23"
      data-caption="prac06.ts (第8形態・全体)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb23-1"><a href="#cb23-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">const</span> grades<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="kw">const</span> gradeListItems <span class="op">=</span> grades<span class="op">.</span><span class="fu">map</span>((grade) <span class="kw">=&gt;</span> <span class="vs">`&lt;li&gt;</span><span class="sc">${</span>grade<span class="sc">}</span><span class="vs">年&lt;/li&gt;`</span>)<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(grades)<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(gradeListItems)<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。</p>
      <pre><code>const grades: number[] = [1, 2, 3, 4, 5];
const gradeListItems = grades.map((grade) =&gt; `&lt;li&gt;${grade}年&lt;/li&gt;`);
console.log(grades);
console.log(gradeListItems);</code></pre>
      <h3 data-number="4.5.9" id="演習②"><span
      class="header-section-number">4.5.9</span> 演習②</h3>
      <p><strong>期待する結果</strong>が得られるように、次のプログラムを完成させてください。ここでは優先度
      (優先順位)「1」が「★★★」で、優先度
      (優先順位)「3」が「★」になる点に注意してください。</p>
      <ul>
      <li><code>map</code> を使用して実装することを意図しています。</li>
      </ul>
      <div class="sourceCode" id="cb25" data-caption="演習 (2)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb25-1"><a href="#cb25-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">const</span> priorities <span class="op">=</span> [<span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span> <span class="co">// 1〜3の値が格納された配列</span></span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">// ここの処理を完成させる</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co">// const formattedPriorities = </span></span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(priorities)<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(formattedPriorities)<span class="op">;</span></span></code></pre></div>
      <p><strong>期待する結果</strong></p>
      <pre><code>[ 3, 1, 2, 1 ]
[ &#39;★&#39;, &#39;★★★&#39;, &#39;★★&#39;, &#39;★★★&#39; ]</code></pre>
      <ul>
      <li>解答例は<a
      href="https://github.com/TakeshiWada1980/Programming3-2024/blob/main/docs/codes/03/code02.ts">こちら<i class="fa-solid fa-person-chalkboard"></i></a></li>
      </ul>
      <h2 data-number="4.6" id="配列のインデックス番号の参照"><span
      class="header-section-number">4.6</span>
      配列のインデックス番号の参照</h2>
      <p>次のプログラムの <strong>第03行目</strong> のように
      <code>map</code> に第2引数を設定すると、その変数には <span
      class="masked">ゼロオリジンのイデックス番号</span>
      が格納され、map内の処理で参照することができます。</p>
      <div class="sourceCode" id="cb27" data-caption="prac06.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb27-1"><a href="#cb27-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">&quot;Python&quot;</span><span class="op">,</span> <span class="st">&quot;C言語&quot;</span><span class="op">,</span> <span class="st">&quot;TypeScript&quot;</span><span class="op">,</span> <span class="st">&quot;C#&quot;</span>]<span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="kw">const</span> arr2 <span class="op">=</span> arr<span class="op">.</span><span class="fu">map</span>((value<span class="op">,</span> index) <span class="kw">=&gt;</span> { <span class="co">// index の設定</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="cf">return</span> <span class="vs">`</span><span class="sc">${</span>index <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="vs">: </span><span class="sc">${</span>value<span class="sc">}</span><span class="vs">`</span><span class="op">;</span> <span class="co">// index の参照 (読み取り)</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>})<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(arr2)<span class="op">;</span></span></code></pre></div>
      <p>実行結果は以下のようになります。</p>
      <pre><code>[ &#39;1: Python&#39;, &#39;2: C言語&#39;, &#39;3: TypeScript&#39;, &#39;4: C#&#39; ]</code></pre>
      <h1 data-number="5" id="オブジェクト配列のmap操作"><span
      class="header-section-number">5</span>
      オブジェクト配列のmap操作</h1>
      <p>次にオブジェクトを要素とする配列の「map操作」について考えていきます。</p>
      <h2 data-number="5.1" id="準備-型定義の変更"><span
      class="header-section-number">5.1</span> 準備 (型定義の変更)</h2>
      <p>前回講義で作成した <code>types.ts</code> の <code>Todo</code>
      の型定義を次のようにアップデートしてください (数値型の
      <code>id</code> というプロパティを追加してください)。</p>
      <div class="sourceCode" id="cb29"
      data-caption="mapによる配列操作の演習"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb29-1"><a href="#cb29-1"></a><span class="im">export type</span> Todo <span class="op">=</span> {</span>
<span id="cb29-2"><a href="#cb29-2"></a>  id<span class="op">:</span> <span class="dt">number</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>  name<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  priority<span class="op">:</span> <span class="dt">number</span><span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>  isDone<span class="op">:</span> <span class="dt">boolean</span><span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>  deadline<span class="op">:</span> <span class="bu">Date</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>}<span class="op">;</span></span></code></pre></div>
      <p>なお、型定義を変更したことで、ここまでに書いてきたプログラムのなかで「<code>Todo</code>
      <strong>を参照していた箇所</strong>」で、次のようなエラーが発生します。</p>
      <figure>
      <img src="figs/03/vscode_02.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <p>これは、エラーメッセージに書かれているとおりで「<code>Todo</code><strong>型の定義には</strong>
      <code>id</code>
      <strong>という数値型のプロパティがあるはずなのに、初期化時に、それを定義しないない</strong>」というエラーメッセージになります。</p>
      <p>これを解決するには、次のいずれかで対応します。</p>
      <ul>
      <li>そのプログラムをコメントアウトする</li>
      <li>初期化の際に <code>id: 1</code>
      のように適当な初期値を持たせる</li>
      <li><code>Todo</code> の型定義で、次のように <code>id</code> を
      <span class="masked">オプショナルなプロパティ ( <span
      class="math inline">\(\neq\)</span> 必須プロパティ)</span>
      に設定する</li>
      </ul>
      <div class="sourceCode" id="cb30"
      data-caption="mapによる配列操作の演習"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb30-1"><a href="#cb30-1"></a><span class="im">export type</span> Todo <span class="op">=</span> {</span>
<span id="cb30-2"><a href="#cb30-2"></a>  id<span class="op">?:</span> <span class="dt">number</span><span class="op">;</span>  <span class="co">// プロパティの名前のあとに ? をつける</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>  name<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>  priority<span class="op">:</span> <span class="dt">number</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>  isDone<span class="op">:</span> <span class="dt">boolean</span><span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>  deadline<span class="op">:</span> <span class="bu">Date</span><span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>}<span class="op">;</span></span></code></pre></div>
      <p>とりあず、<strong>ここでは「初期化の際に</strong>
      <code>id: 1</code>
      <strong>のように適当な初期値を持たせる」で対応してください</strong>。型定義を
      <code>id?</code> にすると、このあとのプログラムが変わっているので
      (<code>id</code>を参照する都度、存在チェックが必要になるので)
      いまは、オプショナルなプロパティにはしないでください。</p>
      <h2 data-number="5.2" id="オブジェクト型の配列の初期化"><span
      class="header-section-number">5.2</span>
      オブジェクト型の配列の初期化</h2>
      <p>ユーザ定義のオブジェクト型を要素に持った
      <strong>配列の初期化</strong>
      は次のように行ないます。<code>src</code> フォルダの直下に
      <code>initTodos.ts</code>
      というファイルを新規作成して以下の内容を記述してください。</p>
      <div class="sourceCode" id="cb31" data-caption="initTodos.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb31-1"><a href="#cb31-1"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="im">export</span> <span class="kw">const</span> initTodos<span class="op">:</span> Todo[] <span class="op">=</span> [</span>
<span id="cb31-4"><a href="#cb31-4"></a>  {</span>
<span id="cb31-5"><a href="#cb31-5"></a>    id<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>    name<span class="op">:</span> <span class="st">&quot;React予習（YouTube）&quot;</span><span class="op">,</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>    isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>    priority<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">24</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="cb31-10"><a href="#cb31-10"></a>  }<span class="op">,</span></span>
<span id="cb31-11"><a href="#cb31-11"></a>  {</span>
<span id="cb31-12"><a href="#cb31-12"></a>    id<span class="op">:</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>    name<span class="op">:</span> <span class="st">&quot;TypeScriptの復習&quot;</span><span class="op">,</span></span>
<span id="cb31-14"><a href="#cb31-14"></a>    isDone<span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb31-15"><a href="#cb31-15"></a>    priority<span class="op">:</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb31-16"><a href="#cb31-16"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">30</span>)<span class="op">,</span></span>
<span id="cb31-17"><a href="#cb31-17"></a>  }<span class="op">,</span></span>
<span id="cb31-18"><a href="#cb31-18"></a>  {</span>
<span id="cb31-19"><a href="#cb31-19"></a>    id<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb31-20"><a href="#cb31-20"></a>    name<span class="op">:</span> <span class="st">&quot;基礎物理学3の宿題&quot;</span><span class="op">,</span></span>
<span id="cb31-21"><a href="#cb31-21"></a>    isDone<span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb31-22"><a href="#cb31-22"></a>    priority<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb31-23"><a href="#cb31-23"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">23</span><span class="op">,</span> <span class="dv">59</span>)<span class="op">,</span></span>
<span id="cb31-24"><a href="#cb31-24"></a>  }<span class="op">,</span></span>
<span id="cb31-25"><a href="#cb31-25"></a>  {</span>
<span id="cb31-26"><a href="#cb31-26"></a>    id<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb31-27"><a href="#cb31-27"></a>    name<span class="op">:</span> <span class="st">&quot;知識科学概論の宿題&quot;</span><span class="op">,</span></span>
<span id="cb31-28"><a href="#cb31-28"></a>    isDone<span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb31-29"><a href="#cb31-29"></a>    priority<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb31-30"><a href="#cb31-30"></a>    deadline<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">27</span>)<span class="op">,</span></span>
<span id="cb31-31"><a href="#cb31-31"></a>  }<span class="op">,</span></span>
<span id="cb31-32"><a href="#cb31-32"></a>]<span class="op">;</span></span></code></pre></div>
      <p>プリミティブ型の配列と同様に、オブジェクト型の配列についても型付きの変数の宣言は
      <code>Todo[]</code> あるいは <code>Array&lt;Todo&gt;</code>
      のようにします。また、初期化は、それに続けて
      <code>=[{...},{...},{...}]</code> の形式で行ないます。</p>
      <h2 data-number="5.3"
      id="オブジェクト型の配列に対するmapの適用"><span
      class="header-section-number">5.3</span>
      オブジェクト型の配列に対するmapの適用</h2>
      <p>ここでは、mapを使って「Todo型のデータ」を「整形された文字列」に変換する例を示します。<code>prac07.ts</code>
      を新規作成して、以下のコードを貼付けてください
      (<code>index.ts</code>も適切に変更してください)。</p>
      <p>ここでは、特に <strong>第07行目</strong>
      に着目して読解してください。</p>
      <ul>
      <li><strong>第11行目</strong> では、前回講義で学習した<a
      href="lecture02.html#条件演算子">条件演算子
      (三項演算子)</a>を利用して、<code>isDone</code> が
      <code>true</code> のときだけ <strong>【済】</strong>
      の文字列が付加されるようにしています。</li>
      <li><strong>第08行目</strong> では、定数 <code>const</code>
      を宣言していますが、この定数を経由せずに直接的に文字列を
      <code>return</code> しても問題ありません。つまり
      <code>return `&lt;li&gt;...&lt;/li&gt;`;</code>
      のようにしても問題ありません
      。さらに、先に解説したように「波括弧」と「<code>return</code>」を省略することも可能です
      (これらは可読性とのトレードオフになります)。</li>
      </ul>
      <div class="sourceCode" id="cb32" data-caption="prac07.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb32-1"><a href="#cb32-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="im">import</span> dayjs <span class="im">from</span> <span class="st">&quot;dayjs&quot;</span><span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">const</span> dtFmt <span class="op">=</span> <span class="st">&quot;YYYY/MM/DD HH:mm&quot;</span><span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="kw">const</span> formattedTodos<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> initTodos<span class="op">.</span><span class="fu">map</span>((t<span class="op">:</span> Todo) <span class="kw">=&gt;</span> {</span>
<span id="cb32-8"><a href="#cb32-8"></a>  <span class="kw">const</span> str <span class="op">=</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="vs">`&lt;li&gt;[</span><span class="sc">${</span>t<span class="op">.</span><span class="at">id</span><span class="sc">}</span><span class="vs">] </span><span class="sc">${</span>t<span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs"> 優先度</span><span class="sc">${</span>t<span class="op">.</span><span class="at">priority</span><span class="sc">}</span><span class="vs"> `</span> <span class="op">+</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="vs">`(期限</span><span class="sc">${</span><span class="fu">dayjs</span>(t<span class="op">.</span><span class="at">deadline</span>)<span class="op">.</span><span class="fu">format</span>(dtFmt)<span class="sc">}</span><span class="vs">)`</span> <span class="op">+</span></span>
<span id="cb32-11"><a href="#cb32-11"></a>    (t<span class="op">.</span><span class="at">isDone</span> <span class="op">?</span> <span class="st">&quot;【済】&quot;</span> <span class="op">:</span> <span class="st">&quot;&quot;</span>) <span class="op">+</span></span>
<span id="cb32-12"><a href="#cb32-12"></a>    <span class="st">&quot;&lt;/li&gt;&quot;</span><span class="op">;</span></span>
<span id="cb32-13"><a href="#cb32-13"></a>  <span class="cf">return</span> str<span class="op">;</span></span>
<span id="cb32-14"><a href="#cb32-14"></a>})<span class="op">;</span></span>
<span id="cb32-15"><a href="#cb32-15"></a></span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(formattedTodos)<span class="op">;</span></span></code></pre></div>
      <p>実行結果は、次のようになります。実際に実行して確認してください。</p>
      <pre><code>[
  &#39;&lt;li&gt;[1] React予習（YouTube） 優先度1 (期限2024/10/24 09:00)&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;[2] TypeScriptの復習 優先度2 (期限2024/10/30 00:00)【済】&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;[3] 基礎物理学3の宿題 優先度1 (期限2024/10/20 23:59)&lt;/li&gt;&#39;,
  &#39;&lt;li&gt;[4] 知識科学概論の宿題 優先度3 (期限2024/10/27 00:00)【済】&lt;/li&gt;&#39;
]</code></pre>
      <p>この例では、Todo型の配列の要素を受け取る仮引数を <code>t</code>
      という名前にしていますが
      (<strong>第07行目</strong>を参照)、これは自由に名前を付けることが可能です。このケースでは
      <code>todo</code> のような名前にするのが一般的です。</p>
      <p>プログラミング1の授業でも紹介しましたが、以下のようにVSCodeの機能で
      <span class="masked">変数名の一括変更</span>
      ができます。通常の一括置換では <span
      class="masked">コメント内の文字列</span>
      なども影響を受けますが、この機能では <strong>変数のスコープ
      (有効範囲)</strong> を識別して適切な置換が実行されます。</p>
      <figure>
      <img src="figs/03/vscode_03.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <h2 data-number="5.4" id="任意の配列要素のプロパティの変更"><span
      class="header-section-number">5.4</span>
      任意の配列要素のプロパティの変更</h2>
      <p>オブジェクト配列のなかの「任意の配列要素」の「任意のプロパティ」を
      <strong>イミュータブルに変更する方法</strong> (その変更が React
      に適切に検知されるようにする方法) を解説します。</p>
      <p>ここでは、<code>id</code> が <code>4</code> である Todo
      (知識科学概論の宿題) の <code>isDone</code> プロパティを
      <code>false</code>
      に変更するような操作を例に解説したいと思います。</p>
      <h3 data-number="5.4.1" id="ng-ミュータブルな操作"><span
      class="header-section-number">5.4.1</span> NG:
      ミュータブルな操作</h3>
      <p>まずはNGな変更操作から確認していきます。次のプログラムの
      <strong>第11行目</strong> から <strong>第16行目</strong>
      までの処理は、<strong>React開発ではNGなミュータブルな操作</strong>
      となります。</p>
      <p>コンソール出力から確認できるように内部データとしては、<code>id</code>
      が <code>4</code> の「知識科学概論の宿題」の <code>isDone</code>
      は <code>false</code>
      に変更されていますが、このような操作ではReactで管理・描画されるウェブ画面上の表示は変更されません
      (Reactでのハマりポイントです)。</p>
      <div class="sourceCode" id="cb34"
      data-caption="prac07.ts (NGな配列要素の更新操作)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb34-1"><a href="#cb34-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3"></a></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更前&quot;</span>)<span class="op">;</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="co">// setTodos(initTodos);</span></span>
<span id="cb34-8"><a href="#cb34-8"></a></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="co">// NGなプロパティ変更</span></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="kw">const</span> targetId <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// isDone を false に戻す対象</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="cf">for</span> (<span class="kw">const</span> todo <span class="kw">of</span> initTodos) {</span>
<span id="cb34-12"><a href="#cb34-12"></a>  <span class="cf">if</span> (todo<span class="op">.</span><span class="at">id</span> <span class="op">===</span> targetId) {</span>
<span id="cb34-13"><a href="#cb34-13"></a>    todo<span class="op">.</span><span class="at">isDone</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb34-14"><a href="#cb34-14"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15"></a>  }</span>
<span id="cb34-16"><a href="#cb34-16"></a>}</span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更後&quot;</span>)<span class="op">;</span></span>
<span id="cb34-18"><a href="#cb34-18"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb34-19"><a href="#cb34-19"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb34-20"><a href="#cb34-20"></a><span class="co">// setTodos(initTodos);</span></span></code></pre></div>
      <p>プログラムのなかでコメントアウトしている
      <code>setTodos(initTodos)</code> は、実際に React
      で状態管理をするときに使用するものです。このような関数を通してReactにデータを渡します。現時点では理解する必要はありません。</p>
      <h3 data-number="5.4.2" id="ok-イミュータブルな操作"><span
      class="header-section-number">5.4.2</span> OK:
      イミュータブルな操作</h3>
      <p>Reactで<strong>画面の再レンダリングがトリガーされるようにするため</strong>には、次のように
      <code>map</code> を使って <strong>配列を新しく作成する</strong>
      (=配列の参照を新しくすることでReactに変更を検知してもらう)
      と共に、<strong>スプレッド構文で操作対象のオブジェクトも新しく作成する</strong>
      (=オブジェクトの参照を新しくすることでReactに変更を検知してもらう)
      必要があります。</p>
      <div class="sourceCode" id="cb35"
      data-caption="prac07.ts (推奨される配列要素の更新操作)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb35-1"><a href="#cb35-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更前&quot;</span>)<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="co">// setTodos(initTodos);</span></span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="co">// 推奨されるプロパティ変更</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="kw">const</span> targetId <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="kw">const</span> updatedTodos <span class="op">=</span> initTodos<span class="op">.</span><span class="fu">map</span>((todo) <span class="kw">=&gt;</span> { <span class="co">// mapメソッドを利用</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>  <span class="cf">if</span> (todo<span class="op">.</span><span class="at">id</span> <span class="op">===</span> targetId) {</span>
<span id="cb35-13"><a href="#cb35-13"></a>    <span class="cf">return</span> { <span class="op">...</span>todo<span class="op">,</span> isDone<span class="op">:</span> <span class="kw">false</span> }<span class="op">;</span> <span class="co">// スプレッド構文を利用</span></span>
<span id="cb35-14"><a href="#cb35-14"></a>  } <span class="cf">else</span> {</span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="cf">return</span> todo<span class="op">;</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>  }</span>
<span id="cb35-17"><a href="#cb35-17"></a>})<span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更後&quot;</span>)<span class="op">;</span></span>
<span id="cb35-19"><a href="#cb35-19"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb35-20"><a href="#cb35-20"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb35-21"><a href="#cb35-21"></a><span class="co">// setTodos(updatedTodos);</span></span></code></pre></div>
      <p>また、上記のプログラムは<a
      href="lecture02.html#三項演算子">条件演算子(三項演算子)</a>を使用して、以下のように記述することができます。</p>
      <div class="sourceCode" id="cb36"
      data-caption="prac07.ts (推奨される配列要素の更新操作・条件演算子)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb36-1"><a href="#cb36-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3"></a></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更前&quot;</span>)<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="co">// setTodos(initTodos);</span></span>
<span id="cb36-8"><a href="#cb36-8"></a></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="kw">const</span> targetId <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="kw">const</span> updatedTodos <span class="op">=</span> initTodos<span class="op">.</span><span class="fu">map</span>((todo) <span class="kw">=&gt;</span> {</span>
<span id="cb36-11"><a href="#cb36-11"></a>  <span class="cf">return</span> todo<span class="op">.</span><span class="at">id</span> <span class="op">===</span> targetId <span class="op">?</span> { <span class="op">...</span>todo<span class="op">,</span> isDone<span class="op">:</span> <span class="kw">false</span> } <span class="op">:</span> todo<span class="op">;</span> <span class="co">// 条件演算子</span></span>
<span id="cb36-12"><a href="#cb36-12"></a>})<span class="op">;</span></span>
<span id="cb36-13"><a href="#cb36-13"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;プロパティ変更後&quot;</span>)<span class="op">;</span></span>
<span id="cb36-14"><a href="#cb36-14"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15"></a><span class="co">// React の useState の更新関数</span></span>
<span id="cb36-16"><a href="#cb36-16"></a><span class="co">// setTodos(updatedTodos);</span></span></code></pre></div>
      <h3 data-number="5.4.3" id="演習③"><span
      class="header-section-number">5.4.3</span> 演習③</h3>
      <p><code>targetId</code> で指定された Todo について
      <code>name</code> のプロパティを
      <strong>イミュータブルに変更</strong>
      するように、次のプログラムを完成させてください。</p>
      <div class="sourceCode" id="cb37" data-caption="演習 (3)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb37-1"><a href="#cb37-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4"></a></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="kw">const</span> targetId <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="kw">const</span> newName <span class="op">=</span> <span class="st">&quot;電気電子回路1の課題&quot;</span><span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">const</span> updatedTodos<span class="op">:</span> Todo[] <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb37-8"><a href="#cb37-8"></a></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <ul>
      <li>解答例は<a
      href="https://github.com/TakeshiWada1980/Programming3-2024/blob/main/docs/codes/03/code03.ts">こちら<i class="fa-solid fa-person-chalkboard"></i></a></li>
      </ul>
      <h1 data-number="6" id="オブジェクト配列のfilter操作"><span
      class="header-section-number">6</span>
      オブジェクト配列のfilter操作</h1>
      <p>配列の <code>map</code> メソッドは
      <strong>引数として関数を受け取り</strong>
      、配列の各要素にその関数を適用した「新しい配列」を作成して戻り値としました。これに対して
      <code>filter</code> メソッドは <code>map</code>
      と同様に<strong>引数として関数を受け取り</strong>ますが、こちらは<span
      class="masked">その関数に配列の各要素を適用した結果が
      <code>true</code> になる要素</span>
      から構成される「新しい配列」を作成して戻り値とします。</p>
      <figure>
      <img src="figs/03/array_01.png" alt="img" />
      <figcaption aria-hidden="true">img</figcaption>
      </figure>
      <h2 data-number="6.1" id="filterメソッドの基本的な使用法"><span
      class="header-section-number">6.1</span>
      filterメソッドの基本的な使用法</h2>
      <p>filter
      メソッドは、配列の<strong>各要素に対して条件</strong>（=<span
      class="masked">真偽値を戻り値とする関数</span>）を適用し、その条件を満たす要素だけを含む「新しい配列」を返す機能を持っています。<code>map</code>
      と同様に元の配列は影響を受けません。</p>
      <p>例えば、次のように使用します。</p>
      <div class="sourceCode" id="cb38"
      data-caption="prac08.ts (filterの使用例)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb38-1"><a href="#cb38-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">const</span> numArr<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span>]<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="kw">const</span> oddArr<span class="op">:</span> <span class="dt">number</span>[] <span class="op">=</span> numArr<span class="op">.</span><span class="fu">filter</span>((num) <span class="kw">=&gt;</span> {</span>
<span id="cb38-4"><a href="#cb38-4"></a>  <span class="cf">return</span> num <span class="op">%</span> <span class="dv">2</span> <span class="op">===</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 奇数か? ture or false</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>})<span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`numArr = </span><span class="sc">${</span>numArr<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`oddArr = </span><span class="sc">${</span>oddArr<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span></code></pre></div>
      <p><strong>第03行目</strong>から<strong>第05行目</strong>は <span
      class="masked"><code>const oddArr = numArr.filter(num =&gt; num % 2 === 1);</code></span>
      のような <strong>省略表記</strong> もできます。</p>
      <p>実行結果は次のようになります。アロー関数で与えた関数による評価結果が
      <code>true</code>
      の要素だけが出力されていることが確認できます。</p>
      <pre><code>numArr = 1,2,3,4,5,6
oddArr = 1,3,5</code></pre>
      <p>なお、<code>numArr.filter(...)</code> の戻り値が <span
      class="masked"><code>[true, false, true, false, true, false]</code></span>
      になるわけ<strong>ではない</strong>ので注意してください
      (逆に、このような配列を得たいときは <span
      class="masked"><code>map</code> メソッド</span>
      を使用してください)。</p>
      <h2 data-number="6.2"
      id="オブジェクト型の配列に対するfilterの適用"><span
      class="header-section-number">6.2</span>
      オブジェクト型の配列に対するfilterの適用</h2>
      <p><code>Todo</code> 型の配列である<code>initTodos</code>
      から「<code>isDone</code> <strong>が</strong> <code>false</code>
      <strong>の要素だけを抽出した配列</strong>」を得る処理は (=これは
      <span class="masked"><code>isDone</code> が <code>true</code>
      の要素を「削除」した配列を得る処理</span> と同義)
      は、<code>filter</code> を使って、次のように実装できます。</p>
      <div class="sourceCode" id="cb40"
      data-caption="prac08.ts (未完了タスク (=isDobeが「false」の要素)の抽出)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb40-1"><a href="#cb40-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="kw">const</span> updatedTodos <span class="op">=</span> initTodos<span class="op">.</span><span class="fu">filter</span>((todo) <span class="kw">=&gt;</span> <span class="op">!</span>todo<span class="op">.</span><span class="at">isDone</span>)<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;未完了Todoの一覧&quot;</span>)<span class="op">;</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p>推測がつくと思いますが、上記の <strong>第04行目</strong> の
      <code>!todo.isDone</code> の <code>!</code> は 真偽値の
      <strong>論理否定演算子</strong>
      です。つまり、<code>todo.isDone</code> が <code>false</code>
      のとき、<code>!todo.isDone</code> は
      <span><code>true</code></span> となりフィルタを通過します。</p>
      <p>また「<strong>任意の</strong> <code>id</code>
      <strong>を持った要素を配列から</strong>「<strong>削除</strong>」<strong>する処理</strong>」も
      <code>filter</code> を利用して、次のように実装が可能です。</p>
      <div class="sourceCode" id="cb41" data-caption="prac08.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb41-1"><a href="#cb41-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3"></a></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="kw">const</span> targetId <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// 削除対象のTodoのID</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="kw">const</span> updatedTodos <span class="op">=</span> initTodos<span class="op">.</span><span class="fu">filter</span>((todo) <span class="kw">=&gt;</span> todo<span class="op">.</span><span class="at">id</span> <span class="op">!==</span> targetId)<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;削除処理後のTodoの一覧&quot;</span>)<span class="op">;</span></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(updatedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <h3 data-number="6.2.1" id="演習④"><span
      class="header-section-number">6.2.1</span> 演習④</h3>
      <p>Todoオブジェクトの配列のなかで「<strong>未完了</strong>」かつ「<strong>期日
      (</strong><code>deadline</code><strong>) が
      </strong><code>today</code>
      <strong>を過ぎている</strong>」に一致する要素を
      <code>overdueTodos</code>
      に得るように、次のプログラムを完成させてください。</p>
      <p>なお、適切な動作検証ができるように <code>initTodos</code>
      を適当に変更してください。</p>
      <div class="sourceCode" id="cb42" data-caption="演習 (4)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb42-1"><a href="#cb42-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4"></a></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="kw">const</span> today <span class="op">=</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="dv">2024</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">22</span>)<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="kw">const</span> overdueTodos<span class="op">:</span> Todo[] <span class="op">=</span> []<span class="op">;</span> <span class="co">// 主にここを書き換え</span></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;期日を過ぎている未完了Todoの一覧&quot;</span>)<span class="op">;</span></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(overdueTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <ul>
      <li>解答例は<a
      href="https://github.com/TakeshiWada1980/Programming3-2024/blob/main/docs/codes/03/code04.ts">こちら<i class="fa-solid fa-person-chalkboard"></i></a></li>
      </ul>
      <h1 data-number="7" id="オブジェクト配列のsort操作"><span
      class="header-section-number">7</span>
      オブジェクト配列のsort操作</h1>
      <p>イミュータブルに配列のソート (並び替え) を行なうためには <span
      class="masked">スプレッド構文</span> と <code>sort</code>
      メソッドを組みあわせて使用します。</p>
      <h2 data-number="7.1"
      id="ソートキーを指定したオブジェクト配列の並び替え"><span
      class="header-section-number">7.1</span>
      ソートキーを指定したオブジェクト配列の並び替え</h2>
      <p>オブジェクト配列の並び替えるには、<code>sort</code>メソッドの引数に
      <span
      class="masked">ソートに使用するプロパティを使った「比較関数」</span>
      を与える必要があります。例えば、Todo を <strong>優先度</strong>
      (<strong>優先順位</strong>)
      の「昇順」にソートする処理は次のように実装できます。</p>
      <div class="sourceCode" id="cb43"
      data-caption="prac09.ts (優先度で並び替え)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb43-1"><a href="#cb43-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="kw">const</span> sortedTodos <span class="op">=</span> [<span class="op">...</span>initTodos]<span class="op">.</span><span class="fu">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> {</span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="cf">return</span> a<span class="op">.</span><span class="at">priority</span> <span class="op">-</span> b<span class="op">.</span><span class="at">priority</span><span class="op">;</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>})<span class="op">;</span></span>
<span id="cb43-7"><a href="#cb43-7"></a></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(sortedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p>実際に実行して、結果を確認してください (特に
      <code>iniTodos</code>
      の並び順は影響を受けていないことを確認してください)。</p>
      <p>また、<strong>第04行目</strong> の
      <code>[...initTodos].sort</code> を <code>initTodos.sort</code>
      に変更すると <span
      class="masked">イミュータブルな操作になってしまうこと (つまり
      <code>initTodos</code> が変更されてしまうこと)</span>
      を実際に確認してください。</p>
      <p><code>sort</code> の引数には、配列の要素となっている型
      (ここでは <code>Todo</code> 型) の2つの引数 (通常 <code>a</code>
      と <code>b</code> という名前にすることが多い)
      を受け取り「<strong>負数</strong> (通常は
      <code>-1</code>)」、「<code>0</code>」、「<strong>正数</strong>
      (通常は
      <code>1</code>)」を返す関数を与えます。この関数は・・・</p>
      <ul>
      <li>要素 <code>a</code> を、要素 <code>b</code>
      よりも「<strong>前</strong>」に並べたいときは <code>-1</code>
      を返すようにします。</li>
      <li>要素 <code>a</code> を、要素 <code>b</code>
      よりも「<strong>後</strong>」に並べたいときは <code>1</code>
      を返すようにします。</li>
      <li>それ以外のとき (両者の順序が同じとき) は <code>0</code>
      を返すようにします。</li>
      </ul>
      <p>一般に、この関数は「<strong>比較関数</strong>」や「<strong>カスタム比較関数</strong>」と呼ばれます。</p>
      <h3 data-number="7.1.1" id="演習"><span
      class="header-section-number">7.1.1</span> 演習</h3>
      <p>Todo を <strong>優先度</strong> (<strong>優先順位</strong>)
      の「降順」にソートする処理を実装してください。また、動作を確認してください。</p>
      <h2 data-number="7.2"
      id="複数のソートキーを使ったオブジェクト配列の並び替え"><span
      class="header-section-number">7.2</span>
      複数のソートキーを使ったオブジェクト配列の並び替え</h2>
      <p>第1ソートキーを <code>isDone</code>
      (<strong>未完了を先に表示</strong>)、第2ソートキーを
      <code>deadline</code>
      として並び替えたいときは、以下のように実装します。</p>
      <div class="sourceCode" id="cb44"
      data-caption="prac09.ts (完了・未完了、期限で並び替え)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb44-1"><a href="#cb44-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4"></a></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="kw">const</span> sortedTodos<span class="op">:</span> Todo[] <span class="op">=</span> [<span class="op">...</span>initTodos]<span class="op">.</span><span class="fu">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> {</span>
<span id="cb44-6"><a href="#cb44-6"></a>  <span class="cf">if</span> (a<span class="op">.</span><span class="at">isDone</span> <span class="op">!==</span> b<span class="op">.</span><span class="at">isDone</span>) {</span>
<span id="cb44-7"><a href="#cb44-7"></a>    <span class="cf">return</span> a<span class="op">.</span><span class="at">isDone</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8"></a>  } <span class="cf">else</span> {</span>
<span id="cb44-9"><a href="#cb44-9"></a>    <span class="cf">return</span> a<span class="op">.</span><span class="at">deadline</span><span class="op">.</span><span class="fu">getTime</span>() <span class="op">-</span> b<span class="op">.</span><span class="at">deadline</span><span class="op">.</span><span class="fu">getTime</span>()<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10"></a>  }</span>
<span id="cb44-11"><a href="#cb44-11"></a>})<span class="op">;</span></span>
<span id="cb44-12"><a href="#cb44-12"></a></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(sortedTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p><strong>第06・07行目</strong> で「<code>a</code> と
      <code>b</code> の <code>isDone</code>
      が<strong>違う</strong>」ならば <code>isDone</code> が
      <code>false</code>
      のほうを「前」に配置するようにしています。また、<strong>第08・09行目</strong>
      で「<code>a</code> と <code>b</code> の <code>isDone</code>
      が<strong>同じ</strong>」ならば <code>deadline</code> が過去のほう
      (古いほう) のほうを「前」に配置するようにしています。</p>
      <h3 data-number="7.2.1" id="演習-1"><span
      class="header-section-number">7.2.1</span> 演習</h3>
      <p>第1ソートキーを「優先度」、第2ソートキーを「期限」として
      <code>Todos</code>
      を並び替えるように実装してください。また、動作を確認してください
      (必要に応じて <code>initTodos</code> に編集を加えてください)。</p>
      <h1 data-number="8"
      id="メソッドチェーン-mapfiltersortの組み合わせ"><span
      class="header-section-number">8</span> メソッドチェーン
      (map・filter・sortの組み合わせ)</h1>
      <p><code>map</code> と <code>filter</code> と <code>sort</code> を
      <strong>連結して使用すること</strong>
      も可能なので知っておいてください
      (実務では頻繁に利用されます)。</p>
      <p>例えば、<code>filter</code>
      で<strong>未完了のTodoだけを抽出</strong>し、<code>sort</code>
      で<strong>優先度順に並べ替え</strong>て、<code>map</code>
      で<strong>整形出力</strong>するという処理は次のように記述できます。このようにメソッドを連結する技法を
      <span class="masked">メソッドチェーン や
      メソッドチェイニング</span> のように表現します。</p>
      <p>なお、<code>sort</code>
      がメソッドチェーンの開始点でなければ、<strong>スプレッド構文を使用せずとも</strong>
      <code>initTodos</code>
      <strong>に対するイミュータブルな操作</strong>となります。もし、<code>sort</code>
      をメソッドチェーンの開始点にする場合は <span
      class="masked"><code>[...initTodos].sort()</code>
      のようにスプレッド構文を組み合わせて使用</span> してください。</p>
      <div class="sourceCode" id="cb45"
      data-caption="prac10.ts (メソッドチェーン)"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb45-1"><a href="#cb45-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="im">import</span> dayjs <span class="im">from</span> <span class="st">&quot;dayjs&quot;</span><span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="kw">const</span> dtFmt <span class="op">=</span> <span class="st">&quot;YYYY/MM/DD HH:mm&quot;</span><span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5"></a></span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="kw">const</span> listItemsTodos<span class="op">:</span> <span class="dt">string</span>[] <span class="op">=</span> initTodos</span>
<span id="cb45-7"><a href="#cb45-7"></a>  <span class="op">.</span><span class="fu">filter</span>((todo) <span class="kw">=&gt;</span> <span class="op">!</span>todo<span class="op">.</span><span class="at">isDone</span>)</span>
<span id="cb45-8"><a href="#cb45-8"></a>  <span class="op">.</span><span class="fu">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> a<span class="op">.</span><span class="at">priority</span> <span class="op">-</span> b<span class="op">.</span><span class="at">priority</span>)</span>
<span id="cb45-9"><a href="#cb45-9"></a>  <span class="op">.</span><span class="fu">map</span>(</span>
<span id="cb45-10"><a href="#cb45-10"></a>    (todo) <span class="kw">=&gt;</span></span>
<span id="cb45-11"><a href="#cb45-11"></a>      <span class="vs">`&lt;li&gt;優先度[</span><span class="sc">${</span>todo<span class="op">.</span><span class="at">priority</span><span class="sc">}</span><span class="vs">] </span><span class="sc">${</span>todo<span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">`</span> <span class="op">+</span></span>
<span id="cb45-12"><a href="#cb45-12"></a>      <span class="vs">`...期限</span><span class="sc">${</span><span class="fu">dayjs</span>(todo<span class="op">.</span><span class="at">deadline</span>)<span class="op">.</span><span class="fu">format</span>(dtFmt)<span class="sc">}</span><span class="vs">&lt;/li&gt;`</span></span>
<span id="cb45-13"><a href="#cb45-13"></a>  )<span class="op">;</span></span>
<span id="cb45-14"><a href="#cb45-14"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(initTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span> <span class="co">// 変更操作の影響を受けていない</span></span>
<span id="cb45-15"><a href="#cb45-15"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(listItemsTodos<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
      <p>実際に上記のプログラムを実行して、出力を確認してください
      (必要に応じて <code>initTodos</code> に編集を加えてください)。</p>
      <h2 data-number="8.1" id="関数化"><span
      class="header-section-number">8.1</span> 関数化</h2>
      <p><code>map</code>、<code>filter</code>、<code>sort</code>
      などの配列操作メソッドは、各種処理をコンパクトに記述することが可能です。ただし、同じ配列操作を2回以上行なうときは、それらの処理を
      <strong>関数化すること</strong> が推奨されます。</p>
      <p>以下のプログラムは、オブジェクト配列 (<code>Todo[]</code>) から
      <code>id</code> をキーに要素を削除した配列を戻り値とする
      <code>deleteTodoById</code>
      関数、オブジェクト配列を受け取って、HTMLに整形した文字列配列を戻り値にする
      <code>stringifyTodos</code> 関数の例となります。</p>
      <div class="sourceCode" id="cb46" data-caption="prac10.ts"><pre
      class="sourceCode numberSource typescript numberLines"><code class="sourceCode typescript"><span id="cb46-1"><a href="#cb46-1"></a><span class="im">export</span> {}<span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="im">import</span> dayjs <span class="im">from</span> <span class="st">&quot;dayjs&quot;</span><span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="im">import</span> { Todo } <span class="im">from</span> <span class="st">&quot;./types&quot;</span><span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="im">import</span> { initTodos } <span class="im">from</span> <span class="st">&quot;./initTodos&quot;</span><span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="kw">const</span> dtFmt <span class="op">=</span> <span class="st">&quot;YYYY/MM/DD HH:mm&quot;</span><span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6"></a></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="kw">const</span> deleteTodoById <span class="op">=</span> (todos<span class="op">:</span> Todo[]<span class="op">,</span> id<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> Todo[] <span class="kw">=&gt;</span> {</span>
<span id="cb46-8"><a href="#cb46-8"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="bu">Number</span><span class="op">.</span><span class="fu">isInteger</span>(id) <span class="op">||</span> id <span class="op">&lt;</span> <span class="dv">0</span>) {</span>
<span id="cb46-9"><a href="#cb46-9"></a>    <span class="cf">return</span> todos<span class="op">;</span></span>
<span id="cb46-10"><a href="#cb46-10"></a>  }</span>
<span id="cb46-11"><a href="#cb46-11"></a>  <span class="cf">return</span> todos<span class="op">.</span><span class="fu">filter</span>((todo) <span class="kw">=&gt;</span> todo<span class="op">.</span><span class="at">id</span> <span class="op">!==</span> id)<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12"></a>}<span class="op">;</span></span>
<span id="cb46-13"><a href="#cb46-13"></a></span>
<span id="cb46-14"><a href="#cb46-14"></a><span class="kw">const</span> stringifyTodos <span class="op">=</span> (todos<span class="op">:</span> Todo[])<span class="op">:</span> <span class="dt">string</span>[] <span class="kw">=&gt;</span></span>
<span id="cb46-15"><a href="#cb46-15"></a>  todos<span class="op">.</span><span class="fu">map</span>(</span>
<span id="cb46-16"><a href="#cb46-16"></a>    (todo) <span class="kw">=&gt;</span></span>
<span id="cb46-17"><a href="#cb46-17"></a>      <span class="vs">`id=</span><span class="sc">${</span>todo<span class="op">.</span><span class="at">id</span><span class="sc">}</span><span class="vs"> </span><span class="sc">${</span>todo<span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs"> `</span> <span class="op">+</span></span>
<span id="cb46-18"><a href="#cb46-18"></a>      <span class="vs">`期限 </span><span class="sc">${</span><span class="fu">dayjs</span>(todo<span class="op">.</span><span class="at">deadline</span>)<span class="op">.</span><span class="fu">format</span>(dtFmt)<span class="sc">}</span><span class="vs">`</span></span>
<span id="cb46-19"><a href="#cb46-19"></a>  )<span class="op">;</span></span>
<span id="cb46-20"><a href="#cb46-20"></a></span>
<span id="cb46-21"><a href="#cb46-21"></a><span class="kw">const</span> todo <span class="op">=</span> [<span class="op">...</span>initTodos]<span class="op">;</span></span>
<span id="cb46-22"><a href="#cb46-22"></a><span class="kw">const</span> updatedTodos <span class="op">=</span> <span class="fu">deleteTodoById</span>(todo<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb46-23"><a href="#cb46-23"></a></span>
<span id="cb46-24"><a href="#cb46-24"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Before:&quot;</span><span class="op">,</span> <span class="fu">stringifyTodos</span>(todo))<span class="op">;</span></span>
<span id="cb46-25"><a href="#cb46-25"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;After:&quot;</span><span class="op">,</span> <span class="fu">stringifyTodos</span>(updatedTodos))<span class="op">;</span></span></code></pre></div>
      <p>慣れるまでは、上記のような関数処理を読み解くことも、記述することも大変かと思います。しかし、React開発では、状態（state）の更新や、コンポーネントの再レンダリングを効率的に行うために
      <strong>頻繁に配列操作メソッドが使用されます</strong>。</p>
      <p>はじめのうちは超難しく感じるかもしれませんが、継続的な学習と実践により、徐々に理解が深まり、効率的なコードを書けるようになります。頑張ってください
      (1回で理解できることは、まず、<strong>あ・り・ま・せ・ん</strong>。1日か2日の間隔を空けて3回ほどトライすると、ぼんやりと分かってくるようになります)。</p>
      <p><strong>(プロンプト例)</strong></p>
      <blockquote>
      <p>React開発のための準備として、TypeScriptにおける配列操作メソッド
      (<code>map</code>、<code>filter</code>、<code>sort</code>)
      の読解と記述について十分に慣れておきたいと思っています。オブジェクトの配列を対象とした配列操作メソッドに関する練習問題と解答例を作成してください。まずは、初歩の初歩、超簡単なものからお願いします。</p>
      </blockquote>
      <h1 data-number="9" id="宿題"><span
      class="header-section-number">9</span> 宿題</h1>
      <p>次回から <strong>本格的なReact開発</strong> に突入します🎉</p>
      <p>予習として以下の動画 (約1時間)
      を視聴してきてほしいです。動画を事前視聴しておくことで
      (=「何が分からないか」を自覚しておくことで)
      授業での理解が格段に進みます。さらに、余裕があれば実際に動画に従って手を動かして「Todoアプリ」を作成してみてください。</p>
      <ul>
      <li><a
      href="https://www.youtube.com/watch?v=nRCNL9T3J98">【React入門】完全初心者OK！1から簡単なTodoアプリを作ってReactの1歩を踏み出してみよう
      ～Reactチュートリアル～</a></li>
      </ul>
      <!-- ---------------------------------------- -->
    </main>

    <footer class="markdown-body">
      <p><a href="https://takeshiwada1980.github.io/Programming3-2024/">講義資料のIndexに移動</a></p>
    </footer>

    <script>
      window.onload = function () {
        // ナビゲーション関連
        let openBtn = document.getElementsByClassName("openbtn")[0];
        let navPnl = document.getElementById("g-nav");
        openBtn.onclick = () => {
          openBtn.classList.toggle("active");
          navPnl.classList.toggle("panelactive");
        };

        let items = navPnl.getElementsByTagName("a");
        Array.from(items).forEach((item) => {
          item.onclick = () => {
            openBtn.classList.toggle("active");
            navPnl.classList.toggle("panelactive");
          };
        });

        // マスク処理
        let maskedSpans = document.getElementsByClassName("masked");
        Array.from(maskedSpans).forEach((span) => {
          span.onclick = () => {
            span.classList.toggle("open");
          };
        });

        // data-startfrom 属性の行番号カウンタのリセット
        document.querySelectorAll("div.sourceCode").forEach(function (div) {
          var startFrom = div.getAttribute("data-startfrom");
          if (startFrom != null) {
            div.style.counterReset = "pg-line " + (startFrom - 1);
          }
        });

        // 画像にリンクを付与
        // let images = document.querySelectorAll("figure img");
        // Array.from(images).forEach((img) => {
        //   img.onclick = () => {
        //     location.href = img.getAttribute("src");
        //   };
        // });
      };
    </script>
  </body>
</html>
